% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sampling_simulations.R
\name{flatten_with_params}
\alias{flatten_with_params}
\title{Flatten with params}
\usage{
flatten_with_params(val, ..., params)
}
\arguments{
\item{val}{The value to copy and substitute parameter expressions with
flattened symbols.}

\item{...}{additional parameters to pass.}

\item{params}{A dictionary or `ParamResolver` where the keys are
`sympy.Symbol`s used by `val` and the values are numbers.}
}
\value{
The list (new value, new params) where new value is `val` with
flattened expressions and new params is a dictionary mapping the new
symbols like `sympy.Symbol('<x + 1>')` to numbers like `params['x'] + 1`.
}
\description{
Creates a copy of `val` with any symbols or
expressions replaced with new symbols.
}
\details{
`val` can be a `Circuit`, `Gate`, `Operation`, or other
type. Also transforms a dictionary of symbol values for `val` to an
equivalent dictionary mapping the new symbols to their evaluated values.
`flatten_with_params` goes through every parameter in `val` and does the
following:
- If the parameter is a number, don't change it.
- If the parameter is a symbol, don't change it and use the same symbol
with the same value in the new dictionary of symbol values.
- If the parameter is an expression, replace it with a symbol and use
the new symbol with the evaluated value of the expression in the new
dictionary of symbol values. The new symbol will be `sympy.Symbol('<x + 1>')`
if the expression was `sympy.Symbol('x') + 1`. In the unlikely case that an
expression with a different meaning also has the string `'x + 1'`, a number
is appended to the name to avoid collision: `sympy.Symbol('<x + 1>_1')`.
}
\section{following}{

- If the parameter is a number, don't change it. - If the parameter is a
symbol, don't change it and use the same symbol with the same value in the
new dictionary of symbol values. - If the parameter is an expression, replace
it with a symbol and use the new symbol with the evaluated value of the
expression in the new dictionary of symbol values. The new symbol will
be `sympy.Symbol('<x + 1>')` if the expression was `sympy.Symbol('x') + 1`.
In the unlikely case that an expression with a different meaning also has
the string `'x + 1'`, a number is appended to the name to avoid
collision: `sympy.Symbol('<x + 1>_1')`.
}

\seealso{
Other Sampling, Simulations and Data collection: 
\code{\link{big_endian_bits_to_int}()},
\code{\link{big_endian_digits_to_int}()},
\code{\link{big_endian_int_to_bits}()},
\code{\link{big_endian_int_to_digits}()},
\code{\link{circuit_like}()},
\code{\link{final_density_matrix}()},
\code{\link{final_wavefunction}()},
\code{\link{flatten_to_ops_or_moments}()},
\code{\link{flatten_to_ops}()},
\code{\link{flatten_with_sweep}()},
\code{\link{flatten}()},
\code{\link{hog_score_xeb_fidelity_from_probabilities}()},
\code{\link{measure_density_matrix}()},
\code{\link{measure_state_vector}()},
\code{\link{random_state_or_seed_like}()},
\code{\link{sample}()}
}
\concept{Sampling, Simulations and Data collection}
